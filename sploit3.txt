Exploit 3
by Saul Laufer
_________

Vulnerability:
target3.c includes code that copies a buffer into another buffer using memcpy(3). There is a check to make sure that the number of bytes being copied does not exceed the length of the local buffer, without an off-by-one error as seen in sploit2. However, the program is vulnerable because it accepts negative values, as well as an unchecked long to int cast. Using strtoul, a int value is taken from a char array, converted from long first. But memcpy accepts an unsigned integer as length, while there is no check to make sure that count isnâ€™t a negative value, or too large to be an int. There are 2 unchecked type conversions in target3.c, meaning that there are 2 type conversions where the input value has not been vetted to determine if the program will behave in its intended manner.

Exploit:
Using 242 as a count, one can calculate the correct buffer size and location of components of a buffer necessary to bring about a root shell. The exploit passes a number that is 242 larger than the maximum int value. strtoul converts the long to an int, overflow converts this to a number that is negative and whose absolute value is 242 greater than the absolute value of the original number. Since the number is negative, it passes the check in foo (count < MAX_WIDGETS == true). When memcpy converts this number to an unsigned int, it becomes +242 and overwrites the return address in the standard buffer overflow manner, as seen in sploit1.